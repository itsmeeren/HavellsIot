Tasks
What is a Task?

A task is basically a function that never returns. It usually contains an infinite while(1) loop. Each task has its own:

    Stack: A private slice of RAM for its local variables.

    Priority: A number telling the CPU how important it is.

    Handle: A reference ID used if you want to delete or pause the task later.

2. The xTaskCreate Parameters

This is the function that actually "spawns" the task. It has 6 essential arguments:
C

xTaskCreate(
    task_function,      // 1. The name of the function to run
    "Task_Name",        // 2. A string name for debugging
    stack_size,         // 3. RAM allocated (usually 2048 or 4096 bytes)
    parameter_to_pass,  // 4. Pointer to data you want to send into the task
    priority,           // 5. Importance (Higher number = Higher priority)
    &task_handle        // 6. Identifier to track the task (optional)
);

3. How "Invoking" Works (The Queue)

In a standard C program, you "invoke" a function by calling its name. In an RTOS, you don't "call" a task‚Äîit‚Äôs already running! Instead, you synchronize or signal it.

To have a "Send" task talk to a "Receive" task (as your mentor suggested), you use a Queue.

    The Receiver Task calls xQueueReceive. If the queue is empty, the task "Blocks" (goes to sleep).

    The Sender Task calls xQueueSend. This places data into the queue.

    The "Invocation": The moment data enters the queue, the FreeRTOS scheduler automatically "wakes up" the Receiver Task to handle it.
1. xQueueSend (The Producer)

This is used by the task that has information to share.
C

xQueueSend(my_queue, &data_to_send, timeout);

    How it works: It copies the data from the sender's local memory into the Queue's internal storage.

    The "Block" (Timeout): If the pipe is full (e.g., you created a queue of size 5 and already sent 5 items), the sender task will actually stop running and wait for the time specified in timeout.

    The Wake-up: As soon as the Receiver takes one item out, the Sender "wakes up" and shoves its data in.

2. xQueueReceive (The Consumer)

This is used by the task that is waiting to do work.
C

xQueueReceive(my_queue, &buffer_to_fill, timeout);

    How it works: It looks at the pipe. If there is data, it copies the oldest item into buffer_to_fill and removes it from the pipe.

    The "Block" (The most important part): If the pipe is empty, the task enters the Blocked State. It uses 0% CPU. It‚Äôs not "checking" the pipe over and over; the FreeRTOS scheduler simply puts the task to sleep.

    The Wake-up: The very microsecond xQueueSend is called by another task, the scheduler instantly wakes up the Receiver to handle the data.
    FreeRTOS Task Arguments (pvParameters): In xTaskCreate, the parameter pvParameters is a mandatory void* pointer that passes specific data (integer, float, or pointer to a struct) to the task, allowing it to functions.
    Station Mode (STA): The ESP32 acts like your phone; it connects to an existing Wi-Fi router.

Access Point Mode (AP): The ESP32 acts like a router; it creates its own Wi-Fi network that you can join with your phone.

Station + AP (Dual Mode): It does both at the same time.
AP MODE OF WIFI
1. The "I am here" (Beaconing)

Even before you touched your phone, the ESP32 started broadcasting Beacon Frames about every 100ms.

    Process: The Wi-Fi radio wakes up, sends a small packet containing the SSID ("Gemini_ESP32_AP") and the security requirements (WPA2), then waits.

    Result: This is why your phone can "see" the network in the Wi-Fi list without you doing anything.

2. The Handshake (Authentication & Association)

When you tapped the name and entered the password, the 802.11 4-Way Handshake began.

    Step A (Probe): Your phone sends a "Probe Request." The ESP32 replies with a "Probe Response."

    Step B (Auth): Your phone says, "I want to join." The ESP32 says, "Prove you have the password."

    Step C (Key Exchange): They exchange mathematical tokens. The actual password is never sent over the air; they use it to generate a PTK (Pairwise Transient Key) to encrypt all future data.

3. The "Name Tag" (DHCP Process)

Once the radio connection is secure, your phone has a "pipe" to the ESP32, but it doesn't have an IP Address yet. This is where the TCP/IP Stack (LwIP) takes over.

    Discovery: Your phone shouts, "Is there a DHCP server here? I need an IP!"

    Offer: The ESP32 (acting as the DHCP Server) replies, "Yes, I am here. You can use 192.168.4.2."

    Request/Ack: Your phone accepts it, and the ESP32 records your phone's MAC Address in its "Lease Table."

4. The Bridge: From Radio to Code

This is the part you see in your terminal.

    The Driver: The physical Wi-Fi hardware detects the connection.

    The Event Loop: The hardware posts an event: WIFI_EVENT_AP_STACONNECTED.

    Your Code: Your wifi_event_handler function was waiting for that specific ID. It woke up, grabbed the MAC address from the event data, and printed it to your screen.

5. Summary of the "Basics" for your Mentor

If your mentor asks how the ESP32-C3 manages multiple phones, you can explain these three layers:

TLS
1. The Concepts You Must Know First

Before we code, your mentor will definitely ask you these three things:

    HTTP (Port 80): Data is sent in "Plain Text." If someone is "listening" to the Wi-Fi, they can see your passwords or data.

    HTTPS (Port 443): This is HTTP inside a TLS tunnel. The data is encrypted.

    TLS/SSL Certificates: How does the ESP32 know it is actually talking to "Google" and not a hacker? Google provides a Certificate (a digital ID). The ESP32 must check this certificate to "trust" the connection.

2. Project Suggestion: The "Secure Fetch"

Let‚Äôs have the ESP32 connect to an HTTPS website (like Google or a public API) and fetch the raw HTML or a JSON response.

Why Google? Google uses very high security. If we can successfully fetch google.com over HTTPS, it proves your TLS stack is working perfectly.

STA MODE
1. The Logic of STA Mode

Unlike AP mode where the ESP32 is the boss, in STA mode the ESP32 is "requesting" entry.

    Init: Turn on the Wi-Fi hardware.

    Config: Give it your Hotspot Name (SSID) and Password.

    Wait for Connection: The hardware tries to find the hotspot.

    Wait for IP: The hotspot's DHCP server assigns an address to the ESP32.

    Ready: Now you can actually use the internet.
3. What to check in your Hotspot

    Band: Make sure your hotspot is set to 2.4 GHz. The ESP32-C3 does not support 5 GHz Wi-Fi.

    Visibility: Ensure your hotspot isn't "Hidden" (though the code can handle it, it's easier to test when visible).

    Connected Devices: Look at your phone‚Äôs hotspot screen‚Äîyou should see a new device join (usually named espressif).

4. Why is this code better than a simple "Connect" call?

The Event Group (xEventGroupWaitBits) is the professional way to do it. It tells the app_main to "freeze" and wait efficiently without wasting CPU power until the Wi-Fi is actually ready. This ensures you don't try to send an HTTP request before you even have an IP.

2Ô∏è‚É£ FULL EXECUTION FLOW (WHAT ACTUALLY HAPPENS)

Let‚Äôs walk exactly like CPU does.

üß† BOOT

ROM bootloader

2nd stage bootloader

FreeRTOS scheduler starts

app_main() is called

üì° STEP 1 ‚Äî Wi-Fi STA MODE
wifi_init_sta();


What happens internally:

TCP/IP stack initialized

Wi-Fi driver loaded

STA mode enabled

ESP connects to AP

DHCP assigns IP

IP_EVENT_STA_GOT_IP fires

EventGroup bit set ‚Üí unblock app

You already knew this part ‚Äî good.

‚è± STEP 2 ‚Äî TIME SYNC (WHY THIS EXISTS)
obtain_time_blocking();


What happens:

SNTP sends UDP packets to NTP server

Receives UNIX time

Sets system RTC clock

Why required:

TLS certificates have valid-from / valid-to dates

If time = 1970
‚û° certificate looks invalid
‚û° TLS handshake fails
‚û° HTTPS fails

üîê STEP 3 ‚Äî HTTPS / TLS
https_task();


Internal flow:

DNS resolve (IPv4)

TCP connection

TLS handshake

Certificate chain verification

HTTP GET

Response received

Certificate validation uses:

esp_crt_bundle_attach


That‚Äôs Espressif‚Äôs built-in trusted CA store.


Phase 1: The Foundation (NVS & Wi-Fi)

    NVS Init: The Wi-Fi driver needs a place to store its internal "calibration" data and Wi-Fi credentials. If this fails, the radio won't even turn on.

    STA Mode Init: You tell the chip: "You are a client, not a router."

    Event Group: This is a flag. The main code stops at xEventGroupWaitBits and sleeps until the Wi-Fi background task waves the "I'm connected!" flag.

    DHCP: Once connected to "Igris," your hotspot gives the ESP32 an IP address. This triggers the IP_EVENT_STA_GOT_IP, which flips the flag and lets the code continue.

Phase 2: The Time Machine (SNTP)

Why is this mandatory? HTTPS relies on Certificates. Every certificate has an "Issue Date" and an "Expiry Date."

    When the ESP32 boots, its internal clock is January 1, 1970.

    Google‚Äôs certificate says: "Valid from 2025 to 2026."

    If you don't sync time, the ESP32 looks at the certificate and says: "This is from the future! I don't trust it." and throws the -0x3000 error.

Process:

    SNTP (Simple Network Time Protocol): The ESP32 sends a tiny packet to pool.ntp.org (a global network of atomic clocks).

    Clock Set: The server sends back the current Unix timestamp. The ESP32 updates its internal RTC (Real Time Clock). Now the year is 2026.

Phase 3: The TLS Handshake (The Secret Sauce)

When esp_http_client_perform starts, the "Handshake" begins. This is the most complex part of the code.

    TCP Connection: ESP32 opens a port (443) to Google.

    Client Hello: ESP32 sends a list of encryption math it supports (like AES-256).

    The Certificate Exchange: Google sends its Public Key and its Certificate.

    Verification (The Bundle): This is where esp_crt_bundle_attach comes in. The ESP32 looks at Google's certificate and checks if it was signed by a "Root Authority" it knows. Since you enabled the bundle in menuconfig, the ESP32 has a "Master List" of trusted authorities. It sees Google is on the list and says: "Okay, you are really Google."

    Key Exchange: They agree on a temporary "session key" that only they know. From this point on, everything is encrypted.

Phase 4: The HTTP Request

Now that the "Encrypted Tunnel" (TLS) is open, the ESP32 sends a standard HTTP GET request inside that tunnel: GET / HTTP/1.1 Host: google.com
Phase 5: The Data Handler

Google sends back a mountain of HTML data. Because this data is huge, the ESP-IDF doesn't give it to you all at once (which would crash the RAM). Instead:

    It arrives in chunks.

    Every time a chunk arrives, the http_event_handler is called.

    Your code uses printf("%.*s", ...) to print that chunk to the screen immediately.

Why these specific lines were necessary:
Code Line	Why it's there
esp_wifi_set_ps(WIFI_PS_NONE)	Critical for C3. Prevents the chip from missing Wi-Fi packets during the heavy math of the TLS handshake.
esp_crt_bundle_attach	Connects the "Trust Database" to the request so you don't have to manually paste certificate files.
obtain_time_blocking	Ensures the year is 2026 so the certificate dates match reality.
xTaskCreate(..., 8192, ...)	TLS uses a lot of "Stack" memory for encryption math. 2048 is too small and would cause a crash.
